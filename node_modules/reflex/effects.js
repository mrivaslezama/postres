"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effects = undefined;

var _task = require("./task");

const raise = error => {
  throw Error(`Effects should be created from task that empty fail but it did fail with error ${error}`);
};

const ignore = _ => void 0;

const nil = _task.Task.succeed(void 0);

const empty = new _task.Task((succeed, fail) => void 0);

class Effects {
  static task(task) {
    console.warn("Effects.task is deprecated please use Effects.perform instead");
    return new Perform(task);
  }
  static perform(task) {
    return new Perform(task);
  }
  static tick(tag) {
    console.warn("Effects.tick is deprecated please use Effects.perform(Task.requestAnimationFrame().map(tag)) instead");
    return new Perform(_task.Task.requestAnimationFrame().map(tag));
  }
  static receive(action) {
    const fx = new Perform(new _task.Task((succeed, fail) => void Promise.resolve(action).then(succeed, fail)));
    return fx;
  }
  static batch(effects) {
    return new Batch(effects);
  }
  map(f) {
    throw Error("Subclass of abstract Effect must implement map");
  }
  execute(address) {
    throw Error("Subclass of abstract Effect must implement execute");
  }
}

exports.Effects = Effects;
class Perform extends Effects {
  constructor(task) {
    super();
    this.task = task;
  }
  map(f) {
    return new Perform(this.task.map(f));
  }
  execute(address) {
    return this.task.chain(value => _task.Task.send(address, value));
  }
}

class None extends Effects {
  map(f) {
    return Effects.none;
  }
  execute(address) {
    return nil;
  }
}
Effects.none = new None();

class Batch extends Effects {
  constructor(effects) {
    super();
    this.effects = effects;
  }
  map(f) {
    return new Batch(this.effects.map(effect => effect.map(f)));
  }
  execute(address) {
    return new _task.Task((succeed, fail) => {
      const { effects } = this;
      const count = effects.length;
      let index = 0;
      while (index < count) {
        const effect = effects[index];
        if (!(effect instanceof None)) {
          _task.Task.fork(effect.execute(address), ignore, raise);
        }

        index = index + 1;
      }
      succeed(void 0);
    });
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9lZmZlY3RzLmpzIl0sIm5hbWVzIjpbInJhaXNlIiwiZXJyb3IiLCJFcnJvciIsImlnbm9yZSIsIl8iLCJuaWwiLCJzdWNjZWVkIiwiZW1wdHkiLCJmYWlsIiwiRWZmZWN0cyIsInRhc2siLCJjb25zb2xlIiwid2FybiIsIlBlcmZvcm0iLCJwZXJmb3JtIiwidGljayIsInRhZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1hcCIsInJlY2VpdmUiLCJhY3Rpb24iLCJmeCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImJhdGNoIiwiZWZmZWN0cyIsIkJhdGNoIiwiZiIsImV4ZWN1dGUiLCJhZGRyZXNzIiwiY29uc3RydWN0b3IiLCJjaGFpbiIsInZhbHVlIiwic2VuZCIsIk5vbmUiLCJub25lIiwiZWZmZWN0IiwiY291bnQiLCJsZW5ndGgiLCJpbmRleCIsImZvcmsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFNQSxNQUFNQSxRQUFRQyxTQUFTO0FBQ3JCLFFBQU1DLE1BQ0gsa0ZBQWlGRCxLQUFNLEVBRHBGLENBQU47QUFHRCxDQUpEOztBQU1BLE1BQU1FLFNBQVNDLEtBQUssS0FBSyxDQUF6Qjs7QUFFQSxNQUFNQyxNQUFNLFdBQUtDLE9BQUwsQ0FBYSxLQUFLLENBQWxCLENBQVo7O0FBRUEsTUFBTUMsUUFBUSxlQUFTLENBQUNELE9BQUQsRUFBVUUsSUFBVixLQUFtQixLQUFLLENBQWpDLENBQWQ7O0FBRU8sTUFBTUMsT0FBTixDQUFpQjtBQUN0QixTQUFPQyxJQUFQLENBQWVBLElBQWYsRUFBaUQ7QUFDL0NDLFlBQVFDLElBQVIsQ0FDRSwrREFERjtBQUdBLFdBQU8sSUFBSUMsT0FBSixDQUFZSCxJQUFaLENBQVA7QUFDRDtBQUNELFNBQU9JLE9BQVAsQ0FBa0JKLElBQWxCLEVBQW9EO0FBQ2xELFdBQU8sSUFBSUcsT0FBSixDQUFZSCxJQUFaLENBQVA7QUFDRDtBQUNELFNBQU9LLElBQVAsQ0FBZUMsR0FBZixFQUFxRDtBQUNuREwsWUFBUUMsSUFBUixDQUNFLHNHQURGO0FBR0EsV0FBTyxJQUFJQyxPQUFKLENBQVksV0FBS0kscUJBQUwsR0FBNkJDLEdBQTdCLENBQWlDRixHQUFqQyxDQUFaLENBQVA7QUFDRDtBQUNELFNBQU9HLE9BQVAsQ0FBa0JDLE1BQWxCLEVBQXlDO0FBQ3ZDLFVBQU1DLEtBQUssSUFBSVIsT0FBSixDQUNULGVBQ0UsQ0FBQ1AsT0FBRCxFQUFVRSxJQUFWLEtBQW1CLEtBQUtjLFFBQVFDLE9BQVIsQ0FBZ0JILE1BQWhCLEVBQXdCSSxJQUF4QixDQUE2QmxCLE9BQTdCLEVBQXNDRSxJQUF0QyxDQUQxQixDQURTLENBQVg7QUFLQSxXQUFPYSxFQUFQO0FBQ0Q7QUFDRCxTQUFPSSxLQUFQLENBQWdCQyxPQUFoQixFQUF3RDtBQUN0RCxXQUFPLElBQUlDLEtBQUosQ0FBVUQsT0FBVixDQUFQO0FBQ0Q7QUFDRFIsTUFBT1UsQ0FBUCxFQUFtQztBQUNqQyxVQUFNMUIsTUFBTSxnREFBTixDQUFOO0FBQ0Q7QUFDRDJCLFVBQVFDLE9BQVIsRUFBZ0Q7QUFDOUMsVUFBTTVCLE1BQU0sb0RBQU4sQ0FBTjtBQUNEO0FBaENxQjs7UUFBWE8sTyxHQUFBQSxPO0FBcUNiLE1BQU1JLE9BQU4sU0FBeUJKLE9BQXpCLENBQW9DO0FBQ2xDc0IsY0FBWXJCLElBQVosRUFBa0M7QUFDaEM7QUFDQSxTQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDRDtBQUNEUSxNQUFPVSxDQUFQLEVBQW1DO0FBQ2pDLFdBQU8sSUFBSWYsT0FBSixDQUFZLEtBQUtILElBQUwsQ0FBVVEsR0FBVixDQUFjVSxDQUFkLENBQVosQ0FBUDtBQUNEO0FBQ0RDLFVBQVFDLE9BQVIsRUFBZ0Q7QUFDOUMsV0FBTyxLQUFLcEIsSUFBTCxDQUFVc0IsS0FBVixDQUFnQkMsU0FBUyxXQUFLQyxJQUFMLENBQVVKLE9BQVYsRUFBbUJHLEtBQW5CLENBQXpCLENBQVA7QUFDRDtBQVZpQzs7QUFhcEMsTUFBTUUsSUFBTixTQUFzQjFCLE9BQXRCLENBQW1DO0FBQ2pDUyxNQUFPVSxDQUFQLEVBQW1DO0FBQ2pDLFdBQU9uQixRQUFRMkIsSUFBZjtBQUNEO0FBQ0RQLFVBQVFDLE9BQVIsRUFBZ0Q7QUFDOUMsV0FBT3pCLEdBQVA7QUFDRDtBQU5nQztBQVFuQ0ksUUFBUTJCLElBQVIsR0FBZSxJQUFJRCxJQUFKLEVBQWY7O0FBRUEsTUFBTVIsS0FBTixTQUF1QmxCLE9BQXZCLENBQWtDO0FBQ2hDc0IsY0FBWUwsT0FBWixFQUF3QztBQUN0QztBQUNBLFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNEO0FBQ0RSLE1BQU9VLENBQVAsRUFBbUM7QUFDakMsV0FBTyxJQUFJRCxLQUFKLENBQVUsS0FBS0QsT0FBTCxDQUFhUixHQUFiLENBQWlCbUIsVUFBVUEsT0FBT25CLEdBQVAsQ0FBV1UsQ0FBWCxDQUEzQixDQUFWLENBQVA7QUFDRDtBQUNEQyxVQUFRQyxPQUFSLEVBQWdEO0FBQzlDLFdBQU8sZUFBUyxDQUFDeEIsT0FBRCxFQUFVRSxJQUFWLEtBQW1CO0FBQ2pDLFlBQU0sRUFBRWtCLE9BQUYsS0FBYyxJQUFwQjtBQUNBLFlBQU1ZLFFBQVFaLFFBQVFhLE1BQXRCO0FBQ0EsVUFBSUMsUUFBUSxDQUFaO0FBQ0EsYUFBT0EsUUFBUUYsS0FBZixFQUFzQjtBQUNwQixjQUFNRCxTQUFTWCxRQUFRYyxLQUFSLENBQWY7QUFDQSxZQUFJLEVBQUVILGtCQUFrQkYsSUFBcEIsQ0FBSixFQUErQjtBQUM3QixxQkFBS00sSUFBTCxDQUFVSixPQUFPUixPQUFQLENBQWVDLE9BQWYsQ0FBVixFQUFtQzNCLE1BQW5DLEVBQTJDSCxLQUEzQztBQUNEOztBQUVEd0MsZ0JBQVFBLFFBQVEsQ0FBaEI7QUFDRDtBQUNEbEMsY0FBUSxLQUFLLENBQWI7QUFDRCxLQWJNLENBQVA7QUFjRDs7QUF2QitCIiwiZmlsZSI6ImVmZmVjdHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4vdGFza1wiXG5cbmltcG9ydCB0eXBlIHsgQWRkcmVzcyB9IGZyb20gXCIuL3NpZ25hbFwiXG5cbmV4cG9ydCB0eXBlIFRpbWUgPSBudW1iZXJcblxuY29uc3QgcmFpc2UgPSBlcnJvciA9PiB7XG4gIHRocm93IEVycm9yKFxuICAgIGBFZmZlY3RzIHNob3VsZCBiZSBjcmVhdGVkIGZyb20gdGFzayB0aGF0IGVtcHR5IGZhaWwgYnV0IGl0IGRpZCBmYWlsIHdpdGggZXJyb3IgJHtlcnJvcn1gXG4gIClcbn1cblxuY29uc3QgaWdub3JlID0gXyA9PiB2b2lkIDBcblxuY29uc3QgbmlsID0gVGFzay5zdWNjZWVkKHZvaWQgMClcblxuY29uc3QgZW1wdHkgPSBuZXcgVGFzaygoc3VjY2VlZCwgZmFpbCkgPT4gdm9pZCAwKVxuXG5leHBvcnQgY2xhc3MgRWZmZWN0czxhPiB7XG4gIHN0YXRpYyB0YXNrPGE+KHRhc2s6IFRhc2s8ZW1wdHksIGE+KTogRWZmZWN0czxhPiB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJFZmZlY3RzLnRhc2sgaXMgZGVwcmVjYXRlZCBwbGVhc2UgdXNlIEVmZmVjdHMucGVyZm9ybSBpbnN0ZWFkXCJcbiAgICApXG4gICAgcmV0dXJuIG5ldyBQZXJmb3JtKHRhc2spXG4gIH1cbiAgc3RhdGljIHBlcmZvcm08YT4odGFzazogVGFzazxlbXB0eSwgYT4pOiBFZmZlY3RzPGE+IHtcbiAgICByZXR1cm4gbmV3IFBlcmZvcm0odGFzaylcbiAgfVxuICBzdGF0aWMgdGljazxhPih0YWc6ICh0aW1lOiBudW1iZXIpID0+IGEpOiBFZmZlY3RzPGE+IHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkVmZmVjdHMudGljayBpcyBkZXByZWNhdGVkIHBsZWFzZSB1c2UgRWZmZWN0cy5wZXJmb3JtKFRhc2sucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkubWFwKHRhZykpIGluc3RlYWRcIlxuICAgIClcbiAgICByZXR1cm4gbmV3IFBlcmZvcm0oVGFzay5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKS5tYXAodGFnKSlcbiAgfVxuICBzdGF0aWMgcmVjZWl2ZTxhPihhY3Rpb246IGEpOiBFZmZlY3RzPGE+IHtcbiAgICBjb25zdCBmeCA9IG5ldyBQZXJmb3JtKFxuICAgICAgbmV3IFRhc2soXG4gICAgICAgIChzdWNjZWVkLCBmYWlsKSA9PiB2b2lkIFByb21pc2UucmVzb2x2ZShhY3Rpb24pLnRoZW4oc3VjY2VlZCwgZmFpbClcbiAgICAgIClcbiAgICApXG4gICAgcmV0dXJuIGZ4XG4gIH1cbiAgc3RhdGljIGJhdGNoPGE+KGVmZmVjdHM6IEFycmF5PEVmZmVjdHM8YT4+KTogRWZmZWN0czxhPiB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaChlZmZlY3RzKVxuICB9XG4gIG1hcDxiPihmOiAoYTogYSkgPT4gYik6IEVmZmVjdHM8Yj4ge1xuICAgIHRocm93IEVycm9yKFwiU3ViY2xhc3Mgb2YgYWJzdHJhY3QgRWZmZWN0IG11c3QgaW1wbGVtZW50IG1hcFwiKVxuICB9XG4gIGV4ZWN1dGUoYWRkcmVzczogQWRkcmVzczxhPik6IFRhc2s8ZW1wdHksIHZvaWQ+IHtcbiAgICB0aHJvdyBFcnJvcihcIlN1YmNsYXNzIG9mIGFic3RyYWN0IEVmZmVjdCBtdXN0IGltcGxlbWVudCBleGVjdXRlXCIpXG4gIH1cbiAgc3RhdGljIG5vbmU6IEVmZmVjdHM8YW55PlxuICB0YXNrOiBUYXNrPGVtcHR5LCBhPlxufVxuXG5jbGFzcyBQZXJmb3JtPGE+IGV4dGVuZHMgRWZmZWN0czxhPiB7XG4gIGNvbnN0cnVjdG9yKHRhc2s6IFRhc2s8ZW1wdHksIGE+KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudGFzayA9IHRhc2tcbiAgfVxuICBtYXA8Yj4oZjogKGE6IGEpID0+IGIpOiBFZmZlY3RzPGI+IHtcbiAgICByZXR1cm4gbmV3IFBlcmZvcm0odGhpcy50YXNrLm1hcChmKSlcbiAgfVxuICBleGVjdXRlKGFkZHJlc3M6IEFkZHJlc3M8YT4pOiBUYXNrPGVtcHR5LCB2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMudGFzay5jaGFpbih2YWx1ZSA9PiBUYXNrLnNlbmQoYWRkcmVzcywgdmFsdWUpKVxuICB9XG59XG5cbmNsYXNzIE5vbmU8YT4gZXh0ZW5kcyBFZmZlY3RzPGFueT4ge1xuICBtYXA8Yj4oZjogKGE6IGEpID0+IGIpOiBFZmZlY3RzPGI+IHtcbiAgICByZXR1cm4gRWZmZWN0cy5ub25lXG4gIH1cbiAgZXhlY3V0ZShhZGRyZXNzOiBBZGRyZXNzPGE+KTogVGFzazxlbXB0eSwgdm9pZD4ge1xuICAgIHJldHVybiBuaWxcbiAgfVxufVxuRWZmZWN0cy5ub25lID0gbmV3IE5vbmUoKVxuXG5jbGFzcyBCYXRjaDxhPiBleHRlbmRzIEVmZmVjdHM8YT4ge1xuICBjb25zdHJ1Y3RvcihlZmZlY3RzOiBBcnJheTxFZmZlY3RzPGE+Pikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzXG4gIH1cbiAgbWFwPGI+KGY6IChhOiBhKSA9PiBiKTogRWZmZWN0czxiPiB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaCh0aGlzLmVmZmVjdHMubWFwKGVmZmVjdCA9PiBlZmZlY3QubWFwKGYpKSlcbiAgfVxuICBleGVjdXRlKGFkZHJlc3M6IEFkZHJlc3M8YT4pOiBUYXNrPGVtcHR5LCB2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBUYXNrKChzdWNjZWVkLCBmYWlsKSA9PiB7XG4gICAgICBjb25zdCB7IGVmZmVjdHMgfSA9IHRoaXNcbiAgICAgIGNvbnN0IGNvdW50ID0gZWZmZWN0cy5sZW5ndGhcbiAgICAgIGxldCBpbmRleCA9IDBcbiAgICAgIHdoaWxlIChpbmRleCA8IGNvdW50KSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGVmZmVjdHNbaW5kZXhdXG4gICAgICAgIGlmICghKGVmZmVjdCBpbnN0YW5jZW9mIE5vbmUpKSB7XG4gICAgICAgICAgVGFzay5mb3JrKGVmZmVjdC5leGVjdXRlKGFkZHJlc3MpLCBpZ25vcmUsIHJhaXNlKVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDFcbiAgICAgIH1cbiAgICAgIHN1Y2NlZWQodm9pZCAwKVxuICAgIH0pXG4gIH1cblxuICBlZmZlY3RzOiBBcnJheTxFZmZlY3RzPGE+PlxufVxuIl19